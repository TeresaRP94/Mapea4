goog.provide( 'M.render.canvas.Replay' );

goog.require( 'ol.render.canvas.Replay' );

/**
 * @namespace M.render.canvas
 */
(function() {
  /**
   * @constructor
   * @extends {ol.render.VectorContext}
   * @param {number} tolerance Tolerance.
   * @param {ol.Extent} maxExtent Maximum extent.
   * @param {number} resolution Resolution.
   * @param {boolean} overlaps The replay can have overlapping geometries.
   * @struct
   */
  M.render.canvas.Replay = function ( tolerance, maxExtent, resolution, overlaps ) {
    ol.render.canvas.Replay.call( this, tolerance, maxExtent, resolution, overlaps );
  };
  ol.inherits( M.render.canvas.Replay, ol.render.canvas.Replay );

  /**
   * @inheritDoc
   * @api stable
   */
  M.render.canvas.Replay.prototype.replay_ = function (
    context, pixelRatio, transform, viewRotation, skippedFeaturesHash,
    instructions, featureCallback, opt_hitExtent ) {
    /** @type {Array.<number>} */
    var pixelCoordinates;
    if ( this.pixelCoordinates_ && ol.array.equals( transform, this.renderedTransform_ ) ) {
      pixelCoordinates = this.pixelCoordinates_;
    }
    else {
      if ( !this.pixelCoordinates_ ) {
        this.pixelCoordinates_ = [];
      }
      pixelCoordinates = ol.geom.flat.transform.transform2D(
        this.coordinates, 0, this.coordinates.length, 2,
        transform, this.pixelCoordinates_ );
      ol.transform.setFromArray( this.renderedTransform_, transform );
    }
    var skipFeatures = !ol.obj.isEmpty( skippedFeaturesHash );
    var i = 0; // instruction index
    var ii = instructions.length; // end of instructions
    var d = 0; // data index
    var dd; // end of per-instruction data
    var localTransform = this.tmpLocalTransform_;
    var resetTransform = this.resetTransform_;
    var prevX, prevY, roundX, roundY;
    var pendingFill = 0;
    var pendingStroke = 0;
    // When the batch size gets too big, performance decreases. 200 is a good
    // balance between batch size and number of fill/stroke instructions.
    var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
    while ( i < ii ) {
      var instruction = instructions[ i ];
      var type = /** @type {ol.render.canvas.Instruction} */ ( instruction[ 0 ] );
      var feature, fill, stroke, text, x, y;
      switch ( type ) {
        case ol.render.canvas.Instruction.BEGIN_GEOMETRY:
          feature = /** @type {ol.Feature|ol.render.Feature} */ ( instruction[ 1 ] );
          if ( ( skipFeatures &&
              skippedFeaturesHash[ ol.getUid( feature ).toString() ] ) ||
            !feature.getGeometry() ) {
            i = /** @type {number} */ ( instruction[ 2 ] );
          }
          else if ( opt_hitExtent !== undefined && !ol.extent.intersects(
              opt_hitExtent, feature.getGeometry().getExtent() ) ) {
            i = /** @type {number} */ ( instruction[ 2 ] ) + 1;
          }
          else {
            ++i;
          }
          break;
        case ol.render.canvas.Instruction.BEGIN_PATH:
          if ( pendingFill > batchSize ) {
            this.fill_( context, viewRotation );
            pendingFill = 0;
          }
          if ( pendingStroke > batchSize ) {
            context.stroke();
            pendingStroke = 0;
          }
          if ( !pendingFill && !pendingStroke ) {
            context.beginPath();
            prevX = prevY = NaN;
          }
          ++i;
          break;
        case ol.render.canvas.Instruction.CIRCLE:
          d = /** @type {number} */ ( instruction[ 1 ] );
          var x1 = pixelCoordinates[ d ];
          var y1 = pixelCoordinates[ d + 1 ];
          var x2 = pixelCoordinates[ d + 2 ];
          var y2 = pixelCoordinates[ d + 3 ];
          var dx = x2 - x1;
          var dy = y2 - y1;
          var r = Math.sqrt( dx * dx + dy * dy );
          context.moveTo( x1 + r, y1 );
          context.arc( x1, y1, r, 0, 2 * Math.PI, true );
          ++i;
          break;
        case ol.render.canvas.Instruction.CLOSE_PATH:
          context.closePath();
          ++i;
          break;
        case ol.render.canvas.Instruction.DRAW_IMAGE:
          d = /** @type {number} */ ( instruction[ 1 ] );
          dd = /** @type {number} */ ( instruction[ 2 ] );
          var image = /** @type {HTMLCanvasElement|HTMLVideoElement|Image} */
            ( instruction[ 3 ] );
          // Remaining arguments in DRAW_IMAGE are in alphabetical order
          var anchorX = /** @type {number} */ ( instruction[ 4 ] ) * pixelRatio;
          var anchorY = /** @type {number} */ ( instruction[ 5 ] ) * pixelRatio;
          var height = /** @type {number} */ ( instruction[ 6 ] );
          var opacity = /** @type {number} */ ( instruction[ 7 ] );
          var originX = /** @type {number} */ ( instruction[ 8 ] );
          var originY = /** @type {number} */ ( instruction[ 9 ] );
          var rotateWithView = /** @type {boolean} */ ( instruction[ 10 ] );
          var rotation = /** @type {number} */ ( instruction[ 11 ] );
          var scale = /** @type {number} */ ( instruction[ 12 ] );
          var snapToPixel = /** @type {boolean} */ ( instruction[ 13 ] );
          var width = /** @type {number} */ ( instruction[ 14 ] );
          if ( rotateWithView ) {
            rotation += viewRotation;
          }
          for ( ; d < dd; d += 2 ) {
            x = pixelCoordinates[ d ] - anchorX;
            y = pixelCoordinates[ d + 1 ] - anchorY;
            if ( snapToPixel ) {
              x = Math.round( x );
              y = Math.round( y );
            }
            if ( scale != 1 || rotation !== 0 ) {
              var centerX = x + anchorX;
              var centerY = y + anchorY;
              ol.transform.compose( localTransform,
                centerX, centerY, scale, scale, rotation, -centerX, -centerY );
              context.setTransform.apply( context, localTransform );
            }
            var alpha = context.globalAlpha;
            if ( opacity != 1 ) {
              context.globalAlpha = alpha * opacity;
            }

            var w = ( width + originX > image.width ) ? image.width - originX : width;
            var h = ( height + originY > image.height ) ? image.height - originY : height;

            context.drawImage( image, originX, originY, w, h,
              x, y, w * pixelRatio, h * pixelRatio );

            if ( opacity != 1 ) {
              context.globalAlpha = alpha;
            }
            if ( scale != 1 || rotation !== 0 ) {
              context.setTransform.apply( context, resetTransform );
            }
          }
          ++i;
          break;
        case ol.render.canvas.Instruction.DRAW_TEXT:
          d = /** @type {number} */ ( instruction[ 1 ] );
          dd = /** @type {number} */ ( instruction[ 2 ] );
          text = /** @type {string} */ ( instruction[ 3 ] );
          var offsetX = /** @type {number} */ ( instruction[ 4 ] ) * pixelRatio;
          var offsetY = /** @type {number} */ ( instruction[ 5 ] ) * pixelRatio;
          rotation = /** @type {number} */ ( instruction[ 6 ] );
          scale = /** @type {number} */ ( instruction[ 7 ] ) * pixelRatio;
          fill = /** @type {boolean} */ ( instruction[ 8 ] );
          stroke = /** @type {boolean} */ ( instruction[ 9 ] );
          rotateWithView = /** @type {boolean} */ ( instruction[ 10 ] );
          if ( rotateWithView ) {
            rotation += viewRotation;
          }
          for ( ; d < dd; d += 2 ) {
            x = pixelCoordinates[ d ] + offsetX;
            y = pixelCoordinates[ d + 1 ] + offsetY;
            if ( scale != 1 || rotation !== 0 ) {
              ol.transform.compose( localTransform, x, y, scale, scale, rotation, -x, -y );
              context.setTransform.apply( context, localTransform );
            }

            // Support multiple lines separated by \n
            var lines = text.split( '\n' );
            var numLines = lines.length;
            var fontSize, lineY;
            if ( numLines > 1 ) {
              // Estimate line height using width of capital M, and add padding
              fontSize = Math.round( context.measureText( 'M' ).width * 1.5 );
              lineY = y - ( ( ( numLines - 1 ) / 2 ) * fontSize );
            }
            else {
              // No need to calculate line height/offset for a single line
              fontSize = 0;
              lineY = y;
            }

            for ( var lineIndex = 0; lineIndex < numLines; lineIndex++ ) {
              var line = lines[ lineIndex ];
              if ( stroke ) {
                context.strokeText( line, x, lineY );
              }
              if ( fill ) {
                context.fillText( line, x, lineY );
              }

              // Move next line down by fontSize px
              lineY = lineY + fontSize;
            }

            if ( scale != 1 || rotation !== 0 ) {
              context.setTransform.apply( context, resetTransform );
            }
          }
          ++i;
          break;
        case ol.render.canvas.Instruction.END_GEOMETRY:
          if ( featureCallback !== undefined ) {
            feature =
              /** @type {ol.Feature|ol.render.Feature} */
              ( instruction[ 1 ] );
            var result = featureCallback( feature );
            if ( result ) {
              return result;
            }
          }
          ++i;
          break;
        case ol.render.canvas.Instruction.FILL:
          if ( batchSize ) {
            pendingFill++;
          }
          else {
            this.fill_( context, viewRotation );
          }
          ++i;
          break;
        case ol.render.canvas.Instruction.MOVE_TO_LINE_TO:
          d = /** @type {number} */ ( instruction[ 1 ] );
          dd = /** @type {number} */ ( instruction[ 2 ] );
          x = pixelCoordinates[ d ];
          y = pixelCoordinates[ d + 1 ];
          roundX = ( x + 0.5 ) | 0;
          roundY = ( y + 0.5 ) | 0;
          if ( roundX !== prevX || roundY !== prevY ) {
            context.moveTo( x, y );
            prevX = roundX;
            prevY = roundY;
          }
          for ( d += 2; d < dd; d += 2 ) {
            x = pixelCoordinates[ d ];
            y = pixelCoordinates[ d + 1 ];
            roundX = ( x + 0.5 ) | 0;
            roundY = ( y + 0.5 ) | 0;
            if ( d == dd - 2 || roundX !== prevX || roundY !== prevY ) {
              context.lineTo( x, y );
              prevX = roundX;
              prevY = roundY;
            }
          }
          ++i;
          break;
        case ol.render.canvas.Instruction.SET_FILL_STYLE:
          this.fillOrigin_ = instruction[ 2 ];

          if ( pendingFill ) {
            this.fill_( context, viewRotation );
            pendingFill = 0;
            if ( pendingStroke ) {
              context.stroke();
              pendingStroke = 0;
            }
          }

          context.fillStyle = /** @type {ol.ColorLike} */ ( instruction[ 1 ] );
          ++i;
          break;
        case ol.render.canvas.Instruction.SET_STROKE_STYLE:
          var usePixelRatio = instruction[ 8 ] !== undefined ?
            instruction[ 8 ] : true;
          var renderedPixelRatio = instruction[ 9 ];

          var lineWidth = /** @type {number} */ ( instruction[ 2 ] );
          if ( pendingStroke ) {
            context.stroke();
            pendingStroke = 0;
          }
          context.strokeStyle = /** @type {ol.ColorLike} */ ( instruction[ 1 ] );
          context.lineWidth = usePixelRatio ? lineWidth * pixelRatio : lineWidth;
          context.lineCap = /** @type {string} */ ( instruction[ 3 ] );
          context.lineJoin = /** @type {string} */ ( instruction[ 4 ] );
          context.miterLimit = /** @type {number} */ ( instruction[ 5 ] );
          if ( ol.has.CANVAS_LINE_DASH ) {
            var lineDash = /** @type {Array.<number>} */ ( instruction[ 6 ] );
            var lineDashOffset = /** @type {number} */ ( instruction[ 7 ] );
            if ( usePixelRatio && pixelRatio !== renderedPixelRatio ) {
              lineDash = lineDash.map( function ( dash ) {
                return dash * pixelRatio / renderedPixelRatio;
              } );
              lineDashOffset *= pixelRatio / renderedPixelRatio;
              instruction[ 6 ] = lineDash;
              instruction[ 7 ] = lineDashOffset;
              instruction[ 9 ] = pixelRatio;
            }
            context.lineDashOffset = lineDashOffset;
            context.setLineDash( lineDash );
          }
          ++i;
          break;
        case ol.render.canvas.Instruction.SET_TEXT_STYLE:
          context.font = /** @type {string} */ ( instruction[ 1 ] );
          context.textAlign = /** @type {string} */ ( instruction[ 2 ] );
          context.textBaseline = /** @type {string} */ ( instruction[ 3 ] );
          ++i;
          break;
        case ol.render.canvas.Instruction.STROKE:
          if ( batchSize ) {
            pendingStroke++;
          }
          else {
            context.stroke();
          }
          ++i;
          break;
        default:
          ++i; // consume the instruction anyway, to avoid an infinite loop
          break;
      }
    }
    if ( pendingFill ) {
      this.fill_( context, viewRotation );
    }
    if ( pendingStroke ) {
      context.stroke();
    }
    return undefined;
  };

})();
