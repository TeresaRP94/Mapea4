import OLFormatGeoJSON from "ol/format/GeoJSON";
import OLFeature from "ol/Feature";
import OLStyle from "ol/style/Style";
import OLIcon from "ol/style/Icon";
import OLProj from "ol/proj";
import Utils from "facade/js/utils/utils";
import Feature from "facade/js/feature/feature";


export default class GeoJSON extends OLFormatGeoJSON {
  /**
   * @classdesc
   * Feature format for reading and writing data in the GeoJSON format.
   *
   * @constructor
   * @extends {ol.format.JSONFeature}
   * @param {olx.format.GeoJSONOptions=} opt_options Options.
   * @api stable
   */
  constructor(opt_options = {}) {
    super(options);
  };

  /**
   * @inheritDoc
   */
  readFeatureFromObject(object, opt_options) {
    let geoJSONFeature = object;
    let geometry = OLFormatGeoJSON.readGeometry_(geoJSONFeature.geometry, opt_options);
    let feature = new OLFeature();
    // geometry
    if (this.geometryName_) {
      feature.setGeometryName(this.geometryName_);
    }
    feature.setGeometry(geometry);
    // id
    if (!Utils.isNullOrEmpty(geoJSONFeature.id)) {
      feature.setId(geoJSONFeature.id);
    }
    else {
      feature.setId(Utils.generateRandom("geojson_"));
    }
    // properties
    if (geoJSONFeature.properties) {
      feature.setProperties(geoJSONFeature.properties);
    }
    // click function
    if (geoJSONFeature.click) {
      feature.click = geoJSONFeature.click;
    }
    // vendor parameters
    if (geoJSONFeature.properties && geoJSONFeature.properties.vendor && geoJSONFeature.properties.vendor.mapea) {
      // icons
      if (geoJSONFeature.properties.vendor.mapea.icon) {
        GeoJSON.applyIcon(feature, geoJSONFeature.properties.vendor.mapea.icon);
      }
    }
    return feature;
  }

  /**
   * @inheritDoc
   */
  writeFeatureObject(feature, opt_options) {
    opt_options = this.adaptOptions(opt_options);
    let object = {
      'type': 'Feature'
    };

    let id = feature.getId();
    if (id) {
      object['id'] = id;
    }
    let geometry = feature.getGeometry();
    if (geometry) {
      object['geometry'] =
        OLFormatGeoJSON.writeGeometry_(geometry, opt_options);
    }
    else {
      object['geometry'] = null;
    }
    let properties = feature.getProperties();
    delete properties[feature.getGeometryName()];
    if (!Utils.isNullOrEmpty(properties)) {
      object['properties'] = properties;
    }
    else {
      object['properties'] = null;
    }

    if (!Utils.isNullOrEmpty(feature.click)) {
      object['click'] = feature.click;
    }
    return object;
  }

  /**
   * @inheritDoc
   */
  readProjectionFromObject(object) {
    let geoJSONObject = object;
    let crs = geoJSONObject.crs;
    if (crs) {
      if (crs.type == 'name') {
        return OLProj.get(crs.properties.name);
      }
      else if (crs.type == 'EPSG') {
        // 'EPSG' is not part of the GeoJSON specification, but is generated by
        // GeoServer.
        // TODO: remove this when http://jira.codehaus.org/browse/GEOS-5996
        // is fixed and widely deployed.
        return OLProj.get('EPSG:' + crs.properties.code);
      }
      else {
        throw new Error('Unknown crs.type: ' + crs.type);
        return null;
      }
    }
    else {
      return "EPSG:4326";
    }
  }


  static applyIcon(feature, icon) {

    let imgIcon = document.createElement('IMG');
    imgIcon.src = icon.url;
    imgIcon.width = icon.width;
    imgIcon.height = icon.height;
    imgIcon.crossOrigin = "anonymous";

    let imgAnchor;
    if (icon.anchor && icon.anchor.x && icon.anchor.y) {
      imgAnchor = [icon.anchor.x, icon.anchor.y];
    }
    feature.setStyle(new OLStyle({
      'image': new OLIcon({
        // 'src': icon.url
        'img': imgIcon,
        'imgSize': [icon.width, icon.height],
        'anchor': imgAnchor
      })
    }));
  }

  /**
   * @inheritDoc
   */
  write(features) {
    return features.map(feature => this.writeFeatureObject(feature.getImpl().getOLFeature()));
  }

  /**
   * This function read Features
   *
   * @public
   * @function
   * @param {object} geojson GeoJSON to parsed as a
   * M.Feature array
   * @return {Array<M.Feature>}
   * @api estable
   */
  read(geojson, geojsonFeatures, projection) {
    let features = [];
    let dstProj = projection.code;
    if (Utils.isNullOrEmpty(dstProj)) {
      if (!Utils.isNullOrEmpty(projection.featureProjection)) {
        dstProj = OLProj.get(projection.featureProjection.getCode());
      }
      else {
        dstProj = OLProj.get(projection.getCode());
      }
    }
    let srcProj = this.readProjectionFromObject(geojson);
    features = geojsonFeatures.map(geojsonFeature => {
        let id = geojsonFeature.id;
        let feature = new Feature(id, geojsonFeature);
        feature.getImpl().getOLFeature().getGeometry().transform(srcProj, dstProj);
        return feature;
      };
      return features;
    }
  }
